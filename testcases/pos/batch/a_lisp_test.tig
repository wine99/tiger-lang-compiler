





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































          function div(args: sexps): int =
            if args = nil
            then (print("Cannot apply / to 0 arguments.\n"); 1)
            else let var curr_arg := args.car
                 in if int_p(curr_arg)
                    then get_int(curr_arg) / times(args.cdr)
                    else (print("Illegal argument to /, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          0)
                 end
          function expt(args: sexps): int =
            if args = nil
            then 1
            else let var curr_arg := args.car
                 in if int_p(curr_arg)
                    then get_int(curr_arg) ^ expt(args.cdr)
                    else (print("Illegal argument to ^, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          0)
                 end

          function lt_int(args: sexps): int =
            let function aux(head: int, args: sexps): int =
                if args = nil
                then 1
                else let var curr_arg := args.car
                     in if int_p(curr_arg)
                        then aux(get_int(curr_arg), args.cdr) & head < get_int(curr_arg)
                        else (print("Illegal argument to <, value: '");
                              print(sexp2s(curr_arg));
                              print("'\n");
                              0)
                     end
            in if args = nil
               then 1
               else let var curr_arg := args.car
                    in if int_p(curr_arg)
                       then aux(get_int(curr_arg), args.cdr)
                       else (print("Illegal argument to <, value: '");
                             print(sexp2s(curr_arg));
                             print("'\n");
                             0)
                    end
            end
          function leq_int(args: sexps): int =
            let function aux(head: int, args: sexps): int =
                if args = nil
                then 1
                else let var curr_arg := args.car
                     in if int_p(curr_arg)
                        then aux(get_int(curr_arg), args.cdr) & head <= get_int(curr_arg)
                        else (print("Illegal argument to <=, value: '");
                              print(sexp2s(curr_arg));
                              print("'\n");
                              0)
                     end
            in if args = nil
               then 1
               else let var curr_arg := args.car
                    in if int_p(curr_arg)
                       then aux(get_int(curr_arg), args.cdr)
                       else (print("Illegal argument to <=, value: '");
                             print(sexp2s(curr_arg));
                             print("'\n");
                             0)
                    end
            end
          function eq_int(args: sexps): int =
            let function aux(head: int, args: sexps): int =
                if args = nil
                then 1
                else let var curr_arg := args.car
                     in if int_p(curr_arg)
                        then aux(head, args.cdr) & get_int(curr_arg) = head
                        else (print("Illegal argument to =, value: '");
                              print(sexp2s(curr_arg));
                              print("'\n");
                              0)
                     end
            in if args = nil
               then 1
               else let var curr_arg := args.car
                    in if int_p(curr_arg)
                       then aux(get_int(curr_arg), args.cdr)
                       else (print("Illegal argument to =, value: '");
                             print(sexp2s(curr_arg));
                             print("'\n");
                             0)
                    end
            end
          function neq_int(args: sexps): int =
            let function aux(head: int, args: sexps): int =
                if args = nil
                then 1
                else let var curr_arg := args.car
                     in if int_p(curr_arg)
                        then aux(head, args.cdr) & get_int(curr_arg) <> head
                        else (print("Illegal argument to !=, value: '");
                              print(sexp2s(curr_arg));
                              print("'\n");
                              0)
                     end
            in if args = nil
               then 1
               else let var curr_arg := args.car
                    in if int_p(curr_arg)
                       then aux(get_int(curr_arg), args.cdr)
                       else (print("Illegal argument to !=, value: '");
                             print(sexp2s(curr_arg));
                             print("'\n");
                             0)
                    end
            end
          function geq_int(args: sexps): int =
            let function aux(head: int, args: sexps): int =
                if args = nil
                then 1
                else let var curr_arg := args.car
                     in if int_p(curr_arg)
                        then aux(get_int(curr_arg), args.cdr) & head >= get_int(curr_arg)
                        else (print("Illegal argument to >=, value: '");
                              print(sexp2s(curr_arg));
                              print("'\n");
                              0)
                     end
            in if args = nil
               then 1
               else let var curr_arg := args.car
                    in if int_p(curr_arg)
                       then aux(get_int(curr_arg), args.cdr)
                       else (print("Illegal argument to >=, value: '");
                             print(sexp2s(curr_arg));
                             print("'\n");
                             0)
                    end
            end
          function gt_int(args: sexps): int =
            let function aux(head: int, args: sexps): int =
                if args = nil
                then 1
                else let var curr_arg := args.car
                     in if int_p(curr_arg)
                        then aux(get_int(curr_arg), args.cdr) & head > get_int(curr_arg)
                        else (print("Illegal argument to >, value: '");
                              print(sexp2s(curr_arg));
                              print("'\n");
                              0)
                     end
            in if args = nil
               then 1
               else let var curr_arg := args.car
                    in if int_p(curr_arg)
                       then aux(get_int(curr_arg), args.cdr)
                       else (print("Illegal argument to >, value: '");
                             print(sexp2s(curr_arg));
                             print("'\n");
                             0)
                    end
            end
          function min(args: sexps): int =
            if args = nil
            then (print("Cannot apply min to 0 arguments\n");
                  0)
            else let var curr_arg := args.car
                 in if int_p(curr_arg)
                    then if args.cdr <> nil
                         then let var min_rst := min(args.cdr)
                              in if get_int(curr_arg) < min_rst
                                 then get_int(curr_arg)
                                 else min_rst
                              end
                         else get_int(curr_arg)
                    else (print("Illegal argument to min, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          0)
                 end
          function max(args: sexps): int =
            if args = nil
            then (print("Cannot apply max to 0 arguments\n");
                  0)
            else let var curr_arg := args.car
                 in if int_p(curr_arg)
                    then if args.cdr <> nil
                         then let var max_rst := max(args.cdr)
                              in if get_int(curr_arg) > max_rst
                                 then get_int(curr_arg)
                                 else max_rst
                              end
                         else get_int(curr_arg)
                    else (print("Illegal argument to min, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          0)
                 end
          function progn(args: sexps): sexp =
            if args = nil
            then (print("Cannot apply progn to 0 arguments.\n");
                  nil)
            else let var curr_arg := args.car
                 in if args.cdr = nil
                    then curr_arg
                    else progn(args.cdr)
                 end
          function map(args: sexps): sexps =
            if args = nil | (args.cdr <> nil & args.cdr.cdr <> nil)
            then (print("map needs exactly 2 arguments.\n");
                  nil)
            else let var fun_arg := args.car
                     var lst_arg := args.cdr.car
                     function aux (args: sexps): sexps =
                       if args = nil
                       then nil
                       else sexps {car = apply_fun_cbv(get_fun(fun_arg),
                                                       sexps {car = args.car,
                                                              cdr = nil},
                                                        env),
                                   cdr = aux(args.cdr)}
                 in if fun_p(fun_arg)
                    then if sexps_p(lst_arg)
                         then aux(get_sexps(lst_arg))
                         else (print("Illegal list argument to map, value: '");
                               print(sexp2s(lst_arg));
                               print("'\n");
                               nil)
                    else (print("Illegal function argument to map, value: '");
                          print(sexp2s(fun_arg));
                          print("'\n");
                          nil)
                 end
          function foldr(args: sexps): sexp =
            if args = nil | args.cdr = nil | (args.cdr.cdr <> nil & args.cdr.cdr.cdr <> nil)
            then (print("foldr needs exactly 3 arguments.\n");
                  nil)
            else let var fun_arg := args.car
                     var init_arg := args.cdr.car
                     var lst_arg := args.cdr.cdr.car
                     function aux(lst: sexps): sexp =
                       if lst = nil
                       then init_arg
                       else apply_fun_cbv(get_fun(fun_arg),
                                          sexps {car = lst.car,
                                                 cdr = sexps {car = aux(lst.cdr),
                                                              cdr = nil}},
                                          env)

                 in if fun_p(fun_arg)
                    then if sexps_p(lst_arg)
                         then aux(get_sexps(lst_arg))
                         else (print("Illegal list argument to foldr, value: '");
                               print(sexp2s(lst_arg));
                               print("'\n");
                               nil)
                    else (print("Illegal function argument to foldr, value: '");
                          print(sexp2s(fun_arg));
                          print("'\n");
                          nil)
                 end
          function foldl(args: sexps): sexp =
            if args = nil | args.cdr = nil | (args.cdr.cdr <> nil & args.cdr.cdr.cdr <> nil)
            then (print("foldl needs exactly 3 arguments.\n");
                  nil)
            else let var fun_arg := args.car
                     var init_arg := args.cdr.car
                     var lst_arg := args.cdr.cdr.car
                     function aux(lst: sexps, acc: sexp): sexp =
                       if lst = nil
                       then acc
                       else aux(lst.cdr, apply_fun_cbv(get_fun(fun_arg),
                                                       sexps {car = lst.car,
                                                              cdr = sexps {car = acc,
                                                                           cdr = nil}},
                                                       env))

                 in if fun_p(fun_arg)
                    then if sexps_p(lst_arg)
                         then aux(get_sexps(lst_arg), init_arg)
                         else (print("Illegal list argument to foldl, value: '");
                               print(sexp2s(lst_arg));
                               print("'\n");
                               nil)
                    else (print("Illegal function argument to foldl, value: '");
                          print(sexp2s(fun_arg));
                          print("'\n");
                          nil)
                 end

          function orb(args: sexps): int =
            if args = nil
            then 0
            else let var curr_arg := args.car
                 in if bool_p(curr_arg)
                    /* We need to call recursively first to prevent |
                     * from short circuiting, as orb is call-by-value */
                    then orb(args.cdr) | get_bool(curr_arg)
                    else (print("Illegal argument to orb, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          0)
                 end
          function andb(args: sexps): int =
            if args = nil
            then 1
            else let var curr_arg := args.car
                 in if bool_p(curr_arg)
                    /* We need to call recursively first to prevent &
                     * from short circuiting, as andb is call-by-value */
                    then andb(args.cdr) & get_bool(curr_arg)
                    else (print("Illegal argument to andb, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          0)
                 end
          function notb(args: sexps): int =
            if args = nil
            then (print("Cannot apply notb to 0 arguments.\n");
                  0)
            else let var curr_arg := args.car
                 in if bool_p(curr_arg) & args.cdr = nil
                    /* We need to call recursively first to prevent &
                     * from short circuiting, as andb is call-by-value */
                    then not(get_bool(curr_arg))
                    else if bool_p(curr_arg)
                    then (print("Illegal argument to notb, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          0)
                    else (print("Cannot apply notb to more than 1 argument.\n");
                          0)
                 end
          function lt_str(args: sexps): int =
            let function aux(head: string, args: sexps): int =
                if args = nil
                then 1
                else let var curr_arg := args.car
                     in if str_p(curr_arg)
                        then aux(get_str(curr_arg), args.cdr) & head < get_str(curr_arg)
                        else (print("Illegal argument to <s, value: '");
                              print(sexp2s(curr_arg));
                              print("'\n");
                              0)
                     end
            in if args = nil
               then 1
               else let var curr_arg := args.car
                    in if str_p(curr_arg)
                       then aux(get_str(curr_arg), args.cdr)
                       else (print("Illegal argument to <s, value: '");
                             print(sexp2s(curr_arg));
                             print("'\n");
                             0)
                    end
            end
          function leq_str(args: sexps): int =
            let function aux(head: string, args: sexps): int =
                if args = nil
                then 1
                else let var curr_arg := args.car
                     in if str_p(curr_arg)
                        then aux(get_str(curr_arg), args.cdr) & head <= get_str(curr_arg)
                        else (print("Illegal argument to <=s, value: '");
                              print(sexp2s(curr_arg));
                              print("'\n");
                              0)
                     end
            in if args = nil
               then 1
               else let var curr_arg := args.car
                    in if str_p(curr_arg)
                       then aux(get_str(curr_arg), args.cdr)
                       else (print("Illegal argument to <=s, value: '");
                             print(sexp2s(curr_arg));
                             print("'\n");
                             0)
                    end
            end
          function eq_str(args: sexps): int =
            let function aux(head: string, args: sexps): int =
                if args = nil
                then 1
                else let var curr_arg := args.car
                     in if str_p(curr_arg)
                        then aux(head, args.cdr) & get_str(curr_arg) = head
                        else (print("Illegal argument to =s, value: '");
                              print(sexp2s(curr_arg));
                              print("'\n");
                              0)
                     end
            in if args = nil
               then 1
               else let var curr_arg := args.car
                    in if str_p(curr_arg)
                       then aux(get_str(curr_arg), args.cdr)
                       else (print("Illegal argument to =s, value: '");
                             print(sexp2s(curr_arg));
                             print("'\n");
                             0)
                    end
            end
          function neq_str(args: sexps): int =
            let function aux(head: string, args: sexps): int =
                if args = nil
                then 1
                else let var curr_arg := args.car
                     in if str_p(curr_arg)
                        then aux(head, args.cdr) & get_str(curr_arg) <> head
                        else (print("Illegal argument to !=s, value: '");
                              print(sexp2s(curr_arg));
                              print("'\n");
                              0)
                     end
            in if args = nil
               then 1
               else let var curr_arg := args.car
                    in if str_p(curr_arg)
                       then aux(get_str(curr_arg), args.cdr)
                       else (print("Illegal argument to !=s, value: '");
                             print(sexp2s(curr_arg));
                             print("'\n");
                             0)
                    end
            end
          function geq_str(args: sexps): int =
            let function aux(head: string, args: sexps): int =
                if args = nil
                then 1
                else let var curr_arg := args.car
                     in if str_p(curr_arg)
                        then aux(get_str(curr_arg), args.cdr) & head >= get_str(curr_arg)
                        else (print("Illegal argument to >=s, value: '");
                              print(sexp2s(curr_arg));
                              print("'\n");
                              0)
                     end
            in if args = nil
               then 1
               else let var curr_arg := args.car
                    in if str_p(curr_arg)
                       then aux(get_str(curr_arg), args.cdr)
                       else (print("Illegal argument to >=s, value: '");
                             print(sexp2s(curr_arg));
                             print("'\n");
                             0)
                    end
            end
          function gt_str(args: sexps): int =
            let function aux(head: string, args: sexps): int =
                if args = nil
                then 1
                else let var curr_arg := args.car
                     in if str_p(curr_arg)
                        then aux(get_str(curr_arg), args.cdr) & head > get_str(curr_arg)
                        else (print("Illegal argument to >s, value: '");
                              print(sexp2s(curr_arg));
                              print("'\n");
                              0)
                     end
            in if args = nil
               then 1
               else let var curr_arg := args.car
                    in if str_p(curr_arg)
                       then aux(get_str(curr_arg), args.cdr)
                       else (print("Illegal argument to >s, value: '");
                             print(sexp2s(curr_arg));
                             print("'\n");
                             0)
                    end
            end
          function append_str(args: sexps): string =
            if args = nil
            then ""
            else let var curr_arg := args.car
                 in if str_p(curr_arg)
                    then concat(get_str(curr_arg), append_str(args.cdr))
                    else (print("Illegal argument to +s, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          "")
                 end
          function str_to_int(args: sexps): int =
            if args = nil | (args.cdr <> nil & args.cdr.cdr <> nil)
            then (print("s->i needs exactly 1 argument.\n");
                  0)
            else let var curr_arg := args.car
                 in if str_p(curr_arg)
                    then s2i(get_str(curr_arg))
                    else (print("Illegal argument to s->i, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          0)
                 end
          function int_to_str(args: sexps): string =
            if args = nil | (args.cdr <> nil & args.cdr.cdr <> nil)
            then (print("i->s needs exactly 1 argument.\n");
                  "")
            else let var curr_arg := args.car
                 in if int_p(curr_arg)
                    then i2s(get_int(curr_arg))
                    else (print("Illegal argument to i->s, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          "")
                 end
          function substring_(args: sexps): string =
            if args = nil | args.cdr = nil | args.cdr.cdr = nil
               | (args.cdr.cdr <> nil & args.cdr.cdr.cdr <> nil)
            then (print("substring needs exactly 3 arguments.\n");
                  "")
            else let var str_arg := args.car
                     var idx_arg := args.cdr.car
                     var len_arg := args.cdr.cdr.car
                 in if str_p(str_arg) & int_p(idx_arg) & int_p(len_arg)
                    then substring(get_str(str_arg), get_int(idx_arg), get_int(len_arg))
                    else (print("Illegal argument to substring, values: '");
                          print(sexp2s(str_arg));
                          print("', '");
                          print(sexp2s(idx_arg));
                          print("', '");
                          print(sexp2s(len_arg));
                          print("'\n");
                          "")
                 end
          function print_(args: sexps): sexps =
            if args = nil
            then nil
            else let var curr_arg := args.car
                 in if str_p(curr_arg)
                    then print(get_str(curr_arg))
                    else print(sexp2s(curr_arg));
                    print_(args.cdr)
                 end
          function newline(args: sexps): sexps =
            if args = nil
            then (print("\n"); nil)
            else (print("newline takes exactly 0 arguments.\n"); nil)
          function read_char_(args: sexps): string =
            if args = nil
            then getchar()
            else (print("read-char takes exactly 0 arguments.\n"); "")
          function read_line_(args: sexps): string =
            if args = nil
            then let var nxt_char := getchar()
                     var res := nxt_char
                 in while nxt_char <> "\n"
                    do (nxt_char := getchar();
                        res := concat(res, nxt_char));
                    res
                 end
            else (print("read-line takes exactly 0 arguments.\n"); "")
          function ord_(args: sexps): int =
            if args = nil | (args.cdr <> nil & args.cdr.cdr <> nil)
            then (print("ord needs exactly 1 argument.\n");
                  0)
            else let var curr_arg := args.car
                 in if str_p(curr_arg)
                    then ord(get_str(curr_arg))
                    else (print("Illegal argument to ord, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          0)
                 end
          function chr_(args: sexps): string =
            if args = nil | (args.cdr <> nil & args.cdr.cdr <> nil)
            then (print("chr needs exactly 1 argument.\n");
                  "")
            else let var curr_arg := args.car
                 in if int_p(curr_arg)
                    then chr(get_int(curr_arg))
                    else (print("Illegal argument to chr, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          "")
                 end



          function list(args: sexps): sexps =
            args
          function cons(args: sexps): sexps =
            if args = nil
            then (print("Cannot apply cons to 0 arguments\n");
                  nil)
            else let var curr_arg := args.car
                 in if args.cdr = nil
                    then if sexps_p(curr_arg)
                         then get_sexps(curr_arg)
                         else (print("Last argument to cons has to be a list. It was '");
                               print(sexp2s(curr_arg));
                               print("'\n");
                               nil)
                    else sexps {car = curr_arg, cdr = cons(args.cdr)}
                 end
          function car(args: sexps): sexp =
            if args = nil | (args.cdr <> nil & args.cdr.cdr <> nil)
            then (print("car needs exactly 1 argument\n");
                  nil)
            else let var curr_arg := args.car
                 in if sexps_p(curr_arg)
                    then let var curr_arg_content := get_sexps(curr_arg)
                         in curr_arg_content.car
                         end
                    else (print("Illegal argument to car, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          nil)
                 end
          function cdr(args: sexps): sexps =
            if args = nil | (args.cdr <> nil & args.cdr.cdr <> nil)
            then (print("cdr needs exactly 1 argument\n");
                  nil)
            else let var curr_arg := args.car
                 in if sexps_p(curr_arg)
                    then let var curr_arg_content := get_sexps(curr_arg)
                         in if curr_arg_content <> nil
                            then curr_arg_content.cdr
                            else (print("Cannot apply cdr to an empty list\n");
                                  nil)
                         end
                    else (print("Illegal argument to cdr, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          nil)
                 end
          function intp(args: sexps): int =
            if args = nil | (args.cdr <> nil & args.cdr.cdr <> nil)
            then (print("int? needs exactly 1 argument.\n");
                  0)
            else let var curr_arg := args.car
                 in int_p(curr_arg)
                 end
          function stringp(args: sexps): int =
            if args = nil | (args.cdr <> nil & args.cdr.cdr <> nil)
            then (print("string? needs exactly 1 argument.\n");
                  0)
            else let var curr_arg := args.car
                 in str_p(curr_arg)
                 end
          function listp(args: sexps): int =
            if args = nil | (args.cdr <> nil & args.cdr.cdr <> nil)
            then (print("list? needs exactly 1 argument.\n");
                  0)
            else let var curr_arg := args.car
                 in sexps_p(curr_arg)
                 end
          function nilp(args: sexps): int =
            if args = nil | (args.cdr <> nil & args.cdr.cdr <> nil)
            then (print("nil? needs exactly 1 argument.\n");
                  0)
            else let var curr_arg := args.car
                 in sexps_p(curr_arg) & get_sexps(curr_arg) = nil
                 end
          function funp(args: sexps): int =
            if args = nil | (args.cdr <> nil & args.cdr.cdr <> nil)
            then (print("fun? needs exactly 1 argument.\n");
                  0)
            else let var curr_arg := args.car
                 in fun_p(curr_arg)
                 end
          function exit_(args: sexps): sexps =
            if args <> nil & args.cdr <> nil
            then (print("exit cannot be used with more that 1 argument.\n");
                  nil)
            else if args = nil
                 then (exit(0); nil)
                 else let var curr_arg := args.car
                      in if int_p(curr_arg)
                         then (exit(get_int(curr_arg)); nil)
                    else (print("Illegal argument to exit, value: '");
                          print(sexp2s(curr_arg));
                          print("'\n");
                          nil)
                      end
          function help(args: sexps): sexps =
            (print("All available entries in the environment at this point are:\n");
             print(env2s_short(env));
             print("\nI hope you find something useful. Oh, and execute '(exit)' to exit.\n");
             nil)
      in if fun_name = "+"
         then mk_int(plus(args))
         else if fun_name = "-"
         then mk_int(minus(args))
         else if fun_name = "*"
         then mk_int(times(args))
         else if fun_name = "/"
         then mk_int(div(args))
         else if fun_name = "^"
         then mk_int(expt(args))
         else if fun_name = "<"
         then mk_bool(lt_int(args))
         else if fun_name = "<="
         then mk_bool(leq_int(args))
         else if fun_name = "="
         then mk_bool(eq_int(args))
         else if fun_name = "!="
         then mk_bool(neq_int(args))
         else if fun_name = ">="
         then mk_bool(geq_int(args))
         else if fun_name = ">"
         then mk_bool(gt_int(args))
         else if fun_name = "min"
         then mk_int(min(args))
         else if fun_name = "max"
         then mk_int(max(args))
         else if fun_name = "progn"
         then progn(args)
         else if fun_name = "map"
         then mk_sexps(map(args))
         else if fun_name = "foldr"
         then foldr(args)
         else if fun_name = "foldl"
         then foldl(args)
         else if fun_name = "orb"
         then mk_bool(orb(args))
         else if fun_name = "andb"
         then mk_bool(andb(args))
         else if fun_name = "notb"
         then mk_bool(andb(args))
         else if fun_name = "<s"
         then mk_bool(lt_str(args))
         else if fun_name = "<=s"
         then mk_bool(leq_str(args))
         else if fun_name = "=s"
         then mk_bool(eq_str(args))
         else if fun_name = "!=s"
         then mk_bool(neq_str(args))
         else if fun_name = ">=s"
         then mk_bool(geq_str(args))
         else if fun_name = ">s"
         then mk_bool(gt_str(args))
         else if fun_name = "+s"
         then mk_str(append_str(args))
         else if fun_name = "s->i"
         then mk_int(str_to_int(args))
         else if fun_name = "i->s"
         then mk_str(int_to_str(args))
         else if fun_name = "substring"
         then mk_str(substring_(args))
         else if fun_name = "print"
         then mk_sexps(print_(args))
         else if fun_name = "newline"
         then mk_sexps(newline(args))
         else if fun_name = "read-char"
         then mk_str(read_char_(args))
         else if fun_name = "read-line"
         then mk_str(read_line_(args))
         else if fun_name = "ord"
         then mk_int(ord_(args))
         else if fun_name = "chr"
         then mk_str(chr_(args))
         else if fun_name = "list"
         then mk_sexps(list(args))
         else if fun_name = "cons"
         then mk_sexps(cons(args))
         else if fun_name = "car"
         then car(args)
         else if fun_name = "cdr"
         then mk_sexps(cdr(args))
         else if fun_name = "int?"
         then mk_bool(intp(args))
         else if fun_name = "string?"
         then mk_bool(stringp(args))
         else if fun_name = "list?"
         then mk_bool(listp(args))
         else if fun_name = "nil?"
         then mk_bool(nilp(args))
         else if fun_name = "fun?"
         then mk_bool(funp(args))
         else if fun_name = "exit"
         then mk_sexps(exit_(args))
         else if fun_name = "help"
         then mk_sexps(help(args))
         else (print("Interpreter error: Unknown internal function '");
               print(fun_name);
               print("' --- Perhaps it has not been implemented yet.\n");
               nil)
      end

    var prompt := ">>> "


in if use_dummy
   then (print("The dummy input is:\n");
         print(dummy_input);
         print("\n"));
   print("Let's spin the REPL... use (exit) if you get too dizzy\n");
   print(prompt);
   init_repl ();
   while 1                      /* Let us hope the user calls exit */
   do (let var tokens := read_sexp_to_tokens ()
           var sexp := parse_tokens(tokens.leftmost, tokens.rightmost)
           var result := eval(sexp, initial_env)
       in print(sexp2s(result));
          print("\n");
          print(prompt)
       end);
   0
end
